<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/sonar-project.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sonar-project.properties" />
              <option name="originalContent" value="sonar.projectKey=digitalnotes&#10;sonar.projectName=Digital Notes&#10;sonar.java.binaries=target/classes&#10;sonar.language=java&#10;sonar.sourceEncoding=UTF-8&#10;sonar.sources=src/main/java&#10;sonar.tests=src/test/java&#10;&#10;" />
              <option name="updatedContent" value="sonar.projectKey=digitalnotes&#10;sonar.projectName=Digital Notes&#10;sonar.java.binaries=target/classes&#10;sonar.language=java&#10;sonar.sourceEncoding=UTF-8&#10;sonar.sources=src/main/java&#10;sonar.tests=src/test/java&#10;sonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml&#10;sonar.junit.reportPaths=target/surefire-reports" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/group6/digitalnotes/dao/LocalizationDAO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/group6/digitalnotes/dao/LocalizationDAO.java" />
              <option name="originalContent" value="package com.group6.digitalnotes.dao;&#10;&#10;import com.group6.digitalnotes.database.DBConnection;&#10;&#10;import java.sql.Connection;&#10;import java.sql.PreparedStatement;&#10;import java.sql.ResultSet;&#10;import java.sql.SQLException;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class LocalizationDAO {&#10;&#10;    // Get a single key and language&#10;    public String getTranslation(String key, String language) {&#10;        String sql = &quot;SELECT value FROM localization_strings WHERE `key` = ? AND language = ? LIMIT 1&quot;;&#10;&#10;        try (Connection conn = DBConnection.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;&#10;            stmt.setString(1, key);&#10;            stmt.setString(2, language);&#10;&#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return rs.getString(&quot;value&quot;);&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;        }&#10;        return null;&#10;    }&#10;&#10;    // Get all translations for a language, Map&lt;key, value&gt;&#10;    public Map&lt;String, String&gt; getTranslationsForLanguage(String language) {&#10;        String sql = &quot;SELECT `key`, value FROM localization_strings WHERE language = ?&quot;;&#10;        Map&lt;String, String&gt; translations = new HashMap&lt;&gt;();&#10;&#10;        try (Connection conn = DBConnection.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;&#10;            stmt.setString(1, language);&#10;&#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    translations.put(rs.getString(&quot;key&quot;), rs.getString(&quot;value&quot;));&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;        }&#10;&#10;        return translations;&#10;    }&#10;&#10;    // default language&#10;    public String getTranslationWithFallback(String key, String language, String defaultLanguage) {&#10;        String value = getTranslation(key, language);&#10;        if (value != null) {&#10;            return value;&#10;        }&#10;        return getTranslation(key, defaultLanguage);&#10;    }&#10;&#10;    // Convenience method used by controllers: load all key/value pairs for a language&#10;    public Map&lt;String, String&gt; loadLanguage(String language) {&#10;        // Delegate to getTranslationsForLanguage so there is a single implementation&#10;        return getTranslationsForLanguage(language);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.group6.digitalnotes.dao;&#10;&#10;import com.group6.digitalnotes.database.DBConnection;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.sql.Connection;&#10;import java.sql.PreparedStatement;&#10;import java.sql.ResultSet;&#10;import java.sql.SQLException;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.Set;&#10;&#10;public class LocalizationDAO {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(LocalizationDAO.class);&#10;    private static final Set&lt;String&gt; VALID_LANGUAGES = Set.of(&quot;en&quot;, &quot;ar&quot;, &quot;ja&quot;);&#10;&#10;    // Get a single key and language&#10;    public String getTranslation(String key, String language) {&#10;        validateLanguage(language);&#10;&#10;        String sql = &quot;SELECT value FROM localization_strings WHERE `key` = ? AND language = ? LIMIT 1&quot;;&#10;&#10;        try (Connection conn = DBConnection.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;&#10;            stmt.setString(1, key);&#10;            stmt.setString(2, language);&#10;&#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return rs.getString(&quot;value&quot;);&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Failed to fetch translation for key: {}, language: {}&quot;, key, language, e);&#10;        }&#10;        return null;&#10;    }&#10;&#10;    // Get all translations for a language, Map&lt;key, value&gt;&#10;    public Map&lt;String, String&gt; getTranslationsForLanguage(String language) {&#10;        validateLanguage(language);&#10;&#10;        String sql = &quot;SELECT `key`, value FROM localization_strings WHERE language = ?&quot;;&#10;        Map&lt;String, String&gt; translations = new HashMap&lt;&gt;();&#10;&#10;        try (Connection conn = DBConnection.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;&#10;            stmt.setString(1, language);&#10;&#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    translations.put(rs.getString(&quot;key&quot;), rs.getString(&quot;value&quot;));&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Failed to fetch translations for language: {}&quot;, language, e);&#10;        }&#10;&#10;        return translations;&#10;    }&#10;&#10;    // default language&#10;    public String getTranslationWithFallback(String key, String language, String defaultLanguage) {&#10;        validateLanguage(language);&#10;        validateLanguage(defaultLanguage);&#10;&#10;        String value = getTranslation(key, language);&#10;        if (value != null) {&#10;            return value;&#10;        }&#10;        logger.warn(&quot;Translation not found for key: {}, language: {}. Falling back to: {}&quot;, key, language, defaultLanguage);&#10;        return getTranslation(key, defaultLanguage);&#10;    }&#10;&#10;    // Convenience method used by controllers: load all key/value pairs for a language&#10;    public Map&lt;String, String&gt; loadLanguage(String language) {&#10;        // Delegate to getTranslationsForLanguage so there is a single implementation&#10;        return getTranslationsForLanguage(language);&#10;    }&#10;&#10;    private void validateLanguage(String language) {&#10;        if (language == null || language.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Language code cannot be null or empty&quot;);&#10;        }&#10;        if (!VALID_LANGUAGES.contains(language)) {&#10;            throw new IllegalArgumentException(&quot;Invalid language code: &quot; + language + &quot;. Supported: &quot; + VALID_LANGUAGES);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/group6/digitalnotes/dao/LocalizationDAOTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/group6/digitalnotes/dao/LocalizationDAOTest.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.group6.digitalnotes.dao;&#10;&#10;import org.junit.jupiter.api.*;&#10;import java.util.Map;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;class LocalizationDAOTest {&#10;&#10;    private LocalizationDAO localizationDAO;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        localizationDAO = new LocalizationDAO();&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Test getTranslation returns correct value for valid key and language&quot;)&#10;    void testGetTranslation_Success() {&#10;        // Test English translation&#10;        String result = localizationDAO.getTranslation(&quot;btn.new&quot;, &quot;en&quot;);&#10;        assertNotNull(result, &quot;Translation should not be null&quot;);&#10;        assertEquals(&quot;New&quot;, result, &quot;Translation should match 'New'&quot;);&#10;&#10;        // Test Arabic translation&#10;        String resultAr = localizationDAO.getTranslation(&quot;btn.new&quot;, &quot;ar&quot;);&#10;        assertNotNull(resultAr, &quot;Arabic translation should not be null&quot;);&#10;        assertEquals(&quot;جديد&quot;, resultAr, &quot;Translation should match Arabic text&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Test getTranslation returns null for non-existent key&quot;)&#10;    void testGetTranslation_NonExistentKey() {&#10;        String result = localizationDAO.getTranslation(&quot;nonexistent.key&quot;, &quot;en&quot;);&#10;        assertNull(result, &quot;Translation should be null for non-existent key&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Test getTranslation throws exception for invalid language&quot;)&#10;    void testGetTranslation_InvalidLanguage() {&#10;        Exception exception = assertThrows(IllegalArgumentException.class, () -&gt; {&#10;            localizationDAO.getTranslation(&quot;btn.new&quot;, &quot;invalid&quot;);&#10;        });&#10;        assertTrue(exception.getMessage().contains(&quot;Invalid language code&quot;));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Test getTranslation throws exception for null language&quot;)&#10;    void testGetTranslation_NullLanguage() {&#10;        Exception exception = assertThrows(IllegalArgumentException.class, () -&gt; {&#10;            localizationDAO.getTranslation(&quot;btn.new&quot;, null);&#10;        });&#10;        assertTrue(exception.getMessage().contains(&quot;cannot be null or empty&quot;));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Test getTranslationsForLanguage returns Map with all translations&quot;)&#10;    void testGetTranslationsForLanguage_Success() {&#10;        Map&lt;String, String&gt; translations = localizationDAO.getTranslationsForLanguage(&quot;en&quot;);&#10;        &#10;        assertNotNull(translations, &quot;Translations map should not be null&quot;);&#10;        assertFalse(translations.isEmpty(), &quot;Translations map should not be empty&quot;);&#10;        assertTrue(translations.containsKey(&quot;btn.new&quot;), &quot;Should contain 'btn.new' key&quot;);&#10;        assertTrue(translations.containsKey(&quot;btn.delete&quot;), &quot;Should contain 'btn.delete' key&quot;);&#10;        assertEquals(&quot;New&quot;, translations.get(&quot;btn.new&quot;), &quot;Value should match 'New'&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Test getTranslationWithFallback returns primary language value&quot;)&#10;    void testGetTranslationWithFallback_PrimaryExists() {&#10;        String result = localizationDAO.getTranslationWithFallback(&quot;btn.new&quot;, &quot;ja&quot;, &quot;en&quot;);&#10;        assertNotNull(result, &quot;Translation should not be null&quot;);&#10;        assertEquals(&quot;新規&quot;, result, &quot;Should return Japanese translation&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Test getTranslationWithFallback returns fallback when primary missing&quot;)&#10;    void testGetTranslationWithFallback_UsesFallback() {&#10;        String result = localizationDAO.getTranslationWithFallback(&quot;nonexistent.key&quot;, &quot;ja&quot;, &quot;en&quot;);&#10;        // Since key doesn't exist in either language, should return null&#10;        assertNull(result, &quot;Should return null when key doesn't exist in both languages&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Test loadLanguage delegates to getTranslationsForLanguage&quot;)&#10;    void testLoadLanguage_Success() {&#10;        Map&lt;String, String&gt; translations = localizationDAO.loadLanguage(&quot;ar&quot;);&#10;        &#10;        assertNotNull(translations, &quot;Translations should not be null&quot;);&#10;        assertFalse(translations.isEmpty(), &quot;Translations should not be empty&quot;);&#10;        assertTrue(translations.containsKey(&quot;btn.new&quot;), &quot;Should contain 'btn.new' key&quot;);&#10;        assertEquals(&quot;جديد&quot;, translations.get(&quot;btn.new&quot;), &quot;Should return Arabic translation&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Test loadLanguage throws exception for invalid language&quot;)&#10;    void testLoadLanguage_InvalidLanguage() {&#10;        Exception exception = assertThrows(IllegalArgumentException.class, () -&gt; {&#10;            localizationDAO.loadLanguage(&quot;fr&quot;);&#10;        });&#10;        assertTrue(exception.getMessage().contains(&quot;Invalid language code&quot;));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Test getTranslationsForLanguage returns empty map for valid language with no data&quot;)&#10;    void testGetTranslationsForLanguage_EmptyResult() {&#10;        // All three languages (en, ar, ja) have data in the DB&#10;        // So we test that it returns data correctly&#10;        Map&lt;String, String&gt; translations = localizationDAO.getTranslationsForLanguage(&quot;en&quot;);&#10;        assertNotNull(translations, &quot;Map should not be null even if empty&quot;);&#10;        assertTrue(translations.size() &gt; 0, &quot;English should have translations in DB&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>